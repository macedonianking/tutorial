/*
 * resource_generator.c
 *
 *  Created on: 2015年6月4日
 *      Author: lhb
 */

#include "resource_table.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "config.h"
#include "item_parse.h"
#include "main_math.h"
#include "main_string.h"
#include "print_util.h"
#include "resource_category.h"
#include "resource_item.h"
#include "scanner.h"

#define MAIN_PRINT_BUFFER_SIZE	2048


main_resource_table *mainResourceTableNew()
{
	main_resource_table *ptr;
	
	ptr = (main_resource_table*) malloc(sizeof(main_resource_table));
	mainResourceTableInitial(ptr, -1);
	return ptr;
}

void mainResourceTableDelete(main_resource_table *ptr)
{
	mainResourceTableRelease(ptr);
	free(ptr);
}

static void mainResourceTableCheckCapacity(main_resource_table *p, int c)
{
	size_t size;
	if (c <= p->c)
		return;
	
	p->c = MAX(p->c * 2, c);
	size = (size_t)(sizeof(main_resource_category) * p->c);
	if (p->head == NULL)
		p->head = (main_resource_category*) malloc(size);
	else
		p->head = (main_resource_category*) realloc(p->head, size);
}

void mainResourceTableInitial(main_resource_table *p, int c)
{
	if (c <= 0)
		c = 20;
	p->c = p->n = 0;
	p->head = NULL;
	p->file_name = NULL;
	mainResourceTableCheckCapacity(p, c);
}

void mainResourceTableRelease(struct main_resource_table *table)
{
	mainResourceTableReset(table);
	free(table->head);
	if (table->file_name)
		free(table->file_name);
	table->file_name = NULL;
	table->c = table->n = 0;
}

main_resource_category *mainResourceTableAppend(main_resource_table *p)
{
	main_resource_category *ptr;
	
	mainResourceTableCheckCapacity(p, p->n + 1);
	ptr = &p->head[p->n++];
	mainResourceCategoryInitial(ptr, -1);
	return ptr;
}

main_resource_category *mainResourceTableSearch(main_resource_table *p, const char *name)
{
	for (int i = 0; i < p->n; ++i) {
		if (strcmp(name, p->head[i].name) == 0)
			return p->head + i;
	}
	return NULL;
}

void mainResourceTableReset(main_resource_table *table)
{
	for (int i = 0; i < table->n; ++i)
		mainResourceCategoryRelease(table->head + i);
	table->n = 0;
}

void mainResourceTablePrint(struct main_resource_table *table, FILE *file)
{
	for (int i = 0; i < table->n; ++i)
		mainResourceCategoryPrint(&table->head[i], file);
}

void mainResourceTablePrintJava(main_resource_table *table, FILE *file,
		struct main_resource_print_options *options)
{
	fprintf(file, "/* AUTO-GENERATED FILE.  DO NOT MODIFY.\n"
			" *\n"
			" * This class was automatically generated by the\n"
			" * aapt tool from the resource data it found.  It\n"
			" * should not be modified by hand.\n"
			" */\n");

	fprintf(file, "package %s;\n", options->package_name);
	fprintf(file, "\n");
	fprintf(file, "public final class R {\n");

	++options->step;
	for (int i = 0; i < table->n; ++i)
		mainResourceCategoryPrintJava(table->head + i, file, options);
	--options->step;

	fprintf(file, "\n}");
}

void mainResourceTableSetFileName(main_resource_table *p, const char *fileName)
{
	if (p->file_name) {
		free(p->file_name);
		p->file_name = NULL;
	}
	if (fileName != NULL) {
		p->file_name = mainStringCloneString(fileName);
	}
}

int mainResourceTableInitFromFile(main_resource_table *table, FILE *file)
{
	main_line_split split;
	const char *line;
	int n;
	int dataType;
	int r;
	main_string typeName;
	main_string itemName;
	main_string itemValue;
	main_resource_category *category;
	main_resource_item *item;
	int nLine;

	r = 0;
	category = NULL;
	mainStringInitial(&typeName);
	mainStringInitial(&itemName);
	mainStringInitial(&itemValue);
	mainLineSplitInitial(&split, file, MAIN_PRINT_BUFFER_SIZE);
	nLine = 0;
	while ((line = mainLineSplitNextLine(&split, &n)) != NULL) {
		if (mainResourceParseItem(line, &dataType, &typeName, &itemName, &itemValue) != 0) {
			printf("parse line failed:%d:%s\n", nLine, line);
			r = 1;
			break;
		}

		if (category == NULL || strcmp(category->name, typeName.data) != 0) {
			category = mainResourceTableSearch(table, typeName.data);
			if (category == NULL) {
				category = mainResourceTableAppend(table);
				category->name = mainStringNewString(&typeName);
			}
		}

		/**
		 * 添加成员 
		 */
		item = mainResourceCategoryAppend(category);
		item->type = dataType;
		item->category = category->name;
		mainResourcItemSetNameValue(item, &itemName, &itemValue);
		++nLine;
	}
	mainLineSplitRelease(&split);
	mainStringRelease(&typeName);
	mainStringRelease(&itemName);
	mainStringRelease(&itemValue);

	return r;
}

static main_resource_item *mainResourceCategorySearch(main_resource_category *cat,
		const char *item_name, int item_type)
{
	main_resource_item *ptr;
	int n;

	ptr = cat->head;
	n = cat->n;
	while (n-- > 0) {
		if (ptr->type == item_type && strcmp(ptr->name, item_name) == 0)
			return ptr;
		++ptr;
	}

	return NULL;
}

static int mainResourceCategoryReplaceImpl(main_resource_category *p, main_resource_table *table, const char *dstFileName)
{
	main_resource_category *q;
	main_resource_item *iter, *target;
	int i;

	q = mainResourceTableSearch(table, p->name);
	if (q == NULL)
		return -1;

	i = 0;
	while (i < p->n) {
		iter = p->head + i;
		target = mainResourceCategorySearch(q, iter->name, iter->type);
		if (target == NULL) {
			if (dstFileName != NULL) {
				fprintf(stdout, "[WARNIG]: resource item '%s' in file '%s' can't be found from the destination resource table",
						iter->name, dstFileName);
			}
			mainResourceCategoryRemove(p, i);
		} else {
			mainResourceItemSetValue(iter, target->value);
			++i;
		}
	}
	return 0;
}

/**
 * 内容替换
 */
int mainResourceTableReplace(main_resource_table *dst, main_resource_table *src)
{
	for (int i = 0; i < dst->n; ++i) {
		if (mainResourceCategoryReplaceImpl(dst->head + i, src, dst->file_name) != 0) {
			return -1;
		}
	}
	return 0;
}
